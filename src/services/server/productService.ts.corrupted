import pool, { executeQuery } from '@/lib/server/mysql';
import { Product } from '@/types/product';
import { saveFile, deleteFile } from '@/lib/fileUpload';
import { v4 as uuidv4 } from 'uuid';

const DEFAULT_PRIMARY_IMAGE_URL = 'https://placehold.co/400x300.png';

// Type for updating product images
export type UpdateProductImageData = {
    imageFiles?: File[] | null;
    newPrimaryImageIndexForUpload?: number;
    makeExistingImagePrimary?: string;
};

// Type for adding new products
export type AddProductData = {
    name: string;
    category: string;
    subCategory: string;
    description: string;
    price: number;
    stockQuantity: number;
    isBestSeller?: boolean;
    imageFiles?: File[];
    primaryImageIndex?: number;
};

// Type for updating products
export type UpdateProductData = {
    name: string;
    category: string;
    subCategory?: string;
    description: string;
    price: number;
    stockQuantity: number;
    isBestSeller: boolean;
    imageUpdateData?: UpdateProductImageData;
};

// Type for today's sales summary
export type TodaysSalesSummary = {
    ordersToday: number;
    salesTodayAmount: number;
};

// Type for product sales summary (for analytics)
export type ProductSaleSummary = {
    productId: string;
    productName: string;
    totalQuantitySold: number;
};

// Type for top sales by quantity in a single order
export type TopSaleByQuantity = {
    id: string;
    productName: string;
    quantitySold: number;
    saleDate: string;
};

// Type for product revenue summary (for analytics)
export type ProductRevenueSummary = {
    productId: string;
    productName: string;
    totalRevenue: number;
};

export async function getProducts(): Promise<Product[]> {
    const connection = await pool.getConnection();
    try {
        const [rows] = await connection.query(`
            SELECT p.*, 
                JSON_ARRAYAGG(
                    JSON_OBJECT(
                        'path', pi.image_path,
                        'isPrimary', pi.is_primary
                    )
                ) as images
            FROM products p
            LEFT JOIN product_images pi ON p.id = pi.product_id
            GROUP BY p.id
            ORDER BY p.created_at DESC
        `) as [any[], any];

        return rows.map(row => ({
            id: row.id,
            name: row.name,
            category: row.category,
            subCategory: row.subcategory || '',
            description: row.description,
            price: Number(row.price),
            stockQuantity: Number(row.stock_quantity) || 0,
            isBestSeller: Boolean(row.is_best_seller),
            createdAt: row.created_at.toISOString(),
            updatedAt: row.updated_at.toISOString(),
            images: row.images && row.images[0] ? 
                JSON.parse(row.images).filter((img: any) => img && img.path).map((img: any) => ({
                    path: img.path,
                    isPrimary: Boolean(img.isPrimary)
                })) : 
                [{ path: DEFAULT_PRIMARY_IMAGE_URL, isPrimary: true }]
        }));
    } catch (error) {
        console.warn("Warning during fetching products:", error);
        return [];
    } finally {
        connection.release();
    }
}

export async function getBestSellingProducts(): Promise<Product[]> {
    const connection = await pool.getConnection();
    try {
        const [rows] = await connection.query(`
            SELECT p.*, 
                JSON_ARRAYAGG(
                    JSON_OBJECT(
                        'path', pi.image_path,
                        'isPrimary', pi.is_primary
                    )
                ) as images
            FROM products p
            LEFT JOIN product_images pi ON p.id = pi.product_id
            WHERE p.is_best_seller = true
            GROUP BY p.id
            ORDER BY p.created_at DESC
        `) as [any[], any];

        return rows.map(row => ({
            id: row.id,
            name: row.name,
            category: row.category,
            subCategory: row.subcategory || '',
            description: row.description,
            price: Number(row.price),
            stockQuantity: Number(row.stock_quantity) || 0,
            isBestSeller: true,
            createdAt: row.created_at.toISOString(),
            updatedAt: row.updated_at.toISOString(),
            images: row.images && row.images[0] ? 
                JSON.parse(row.images).filter((img: any) => img && img.path).map((img: any) => ({
                    path: img.path,
                    isPrimary: Boolean(img.isPrimary)
                })) : 
                [{ path: DEFAULT_PRIMARY_IMAGE_URL, isPrimary: true }]
        }));
    } catch (error) {
        console.warn("Warning during fetching best selling products:", error);
        return [];
    } finally {
        connection.release();
    }
}

export async function getMostRecentProduct(): Promise<Product | null> {
    const connection = await pool.getConnection();
    try {
        const [rows] = await connection.query(`
            SELECT p.*, 
                JSON_ARRAYAGG(
                    JSON_OBJECT(
                        'path', pi.image_path,
                        'isPrimary', pi.is_primary
                    )
                ) as images
            FROM products p
            LEFT JOIN product_images pi ON p.id = pi.product_id
            GROUP BY p.id
            ORDER BY p.created_at DESC
            LIMIT 1
        `) as [any[], any];

        if (!rows.length) return null;

        const row = rows[0];
        return {
            id: row.id,
            name: row.name,
            category: row.category,
            subCategory: row.subcategory || '',
            description: row.description,
            price: Number(row.price),
            stockQuantity: Number(row.stock_quantity) || 0,
            isBestSeller: Boolean(row.is_best_seller),
            createdAt: row.created_at.toISOString(),
            updatedAt: row.updated_at.toISOString(),
            images: row.images && row.images[0] ? 
                JSON.parse(row.images).filter((img: any) => img && img.path).map((img: any) => ({
                    path: img.path,
                    isPrimary: Boolean(img.isPrimary)
                })) : 
                [{ path: DEFAULT_PRIMARY_IMAGE_URL, isPrimary: true }]
        };
    } catch (error) {
        console.warn("Warning during fetching most recent product:", error);
        return null;
    } finally {
        connection.release();
    }
}

export async function getProductById(productId: string): Promise<Product | null> {
    const connection = await pool.getConnection();
    try {
        const [rows] = await connection.query(`
            SELECT p.*, 
                JSON_ARRAYAGG(
                    JSON_OBJECT(
                        'path', pi.image_path,
                        'isPrimary', pi.is_primary
                    )
                ) as images
            FROM products p
            LEFT JOIN product_images pi ON p.id = pi.product_id
            WHERE p.id = ?
            GROUP BY p.id
        `, [productId]) as [any[], any];

        if (!rows.length) return null;

        const row = rows[0];
        return {
            id: row.id,
            name: row.name,
            category: row.category,
            subCategory: row.subcategory || '',
            description: row.description,
            price: Number(row.price),
            stockQuantity: Number(row.stock_quantity) || 0,
            isBestSeller: Boolean(row.is_best_seller),
            createdAt: row.created_at ? row.created_at.toISOString() : null,
            updatedAt: row.updated_at ? row.updated_at.toISOString() : null,
            images: row.images && row.images[0] ? 
                JSON.parse(row.images).filter((img: any) => img && img.path).map((img: any) => ({
                    path: img.path,
                    isPrimary: Boolean(img.isPrimary)
                })) : 
                [{ path: DEFAULT_PRIMARY_IMAGE_URL, isPrimary: true }]
        };
    } catch (error) {
        console.warn(`Warning during fetching product ${productId}:`, error);
        return null;
    } finally {
        connection.release();
    }
}

export async function addProduct(productData: AddProductData): Promise<{ success: boolean; productId?: string; error?: string }> {
    const connection = await pool.getConnection();
    try {
        await connection.beginTransaction();
        
        const productId = uuidv4();
        
        // Insert product
        await connection.query(`
            INSERT INTO products (
                id, name, category, subcategory, description, 
                price, stock_quantity, is_best_seller, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
        `, [
            productId,
            productData.name,
            productData.category,
            productData.subCategory || '',
            productData.description,
            productData.price,
            productData.stockQuantity,
            Boolean(productData.isBestSeller)
        ]);

        // Handle image uploads if provided
        if (productData.imageFiles?.length) {
            for (let i = 0; i < productData.imageFiles.length; i++) {
                const file = productData.imageFiles[i];
                const uploadResult = await saveFile('products', file);
                
                if (!uploadResult.success || !uploadResult.path) {
                    throw new Error(`Failed to upload image ${file.name}: ${uploadResult.error}`);
                }
                
                await connection.query(`
                    INSERT INTO product_images (
                        product_id, image_path, is_primary, created_at, updated_at
                    ) VALUES (?, ?, ?, NOW(), NOW())
                `, [
                    productId,
                    uploadResult.path,
                    i === (productData.primaryImageIndex || 0)
                ]);
            }
        }

        await connection.commit();
        return { success: true, productId };
    } catch (error) {
        await connection.rollback();
        console.error('Error in addProduct:', error);
        return { 
            success: false, 
            error: error instanceof Error ? error.message : 'Failed to create product' 
        };
    } finally {
        connection.release();
    }
}

export async function updateProduct(productId: string, productData: Partial<UpdateProductData>): Promise<{ success: boolean; error?: string }> {
    const connection = await pool.getConnection();
    try {
        await connection.beginTransaction();

        // If only isBestSeller is being updated, use a simpler query
        if (Object.keys(productData).length === 1 && 'isBestSeller' in productData) {
            await connection.query(
                'UPDATE products SET is_best_seller = ?, updated_at = NOW() WHERE id = ?',
                [Boolean(productData.isBestSeller), productId]
            );
            await connection.commit();
            return { success: true };
        }

        // Get current product data for any missing fields
        const [rows] = await connection.query('SELECT * FROM products WHERE id = ?', [productId]) as [any[], any];
        if (rows.length === 0) {
            throw new Error('Product not found');
        }
        const current = rows[0];

        // Update product with merged data
        await connection.query(
            'UPDATE products SET name = ?, category = ?, subcategory = ?, description = ?, price = ?, stock_quantity = ?, is_best_seller = ?, updated_at = NOW() WHERE id = ?',
            [
                productData.name ?? current.name,
                productData.category ?? current.category,
                productData.subCategory ?? current.subcategory ?? '',
                productData.description ?? current.description,
                productData.price ?? current.price,
                productData.stockQuantity ?? current.stock_quantity,
                productData.isBestSeller !== undefined ? Boolean(productData.isBestSeller) : Boolean(current.is_best_seller),
                productId
            ]
        );

        // Handle image updates if provided
        if (productData.imageUpdateData) {
            const { imageFiles, makeExistingImagePrimary, newPrimaryImageIndexForUpload } = productData.imageUpdateData;

            // If making an existing image primary
            if (makeExistingImagePrimary) {
                await connection.query(
                    'UPDATE product_images SET is_primary = CASE WHEN image_path = ? THEN true ELSE false END, updated_at = NOW() WHERE product_id = ?',
                    [makeExistingImagePrimary, productId]
                );
            }

            // If new images are being uploaded
            if (Array.isArray(imageFiles) && imageFiles.length > 0) {
                // Delete all existing images first
                await connection.query('DELETE FROM product_images WHERE product_id = ?', [productId]);

                // Upload and save new images
                for (let i = 0; i < imageFiles.length; i++) {
                    const file = imageFiles[i];
                    if (typeof file === 'string') {
                        const uploadResult = await saveFile(file, 'uploads/products/' + productId);
                        await connection.query(
                            'INSERT INTO product_images (product_id, image_path, is_primary, created_at, updated_at) VALUES (?, ?, ?, NOW(), NOW())',
                            [
                                productId,
                                uploadResult.path,
                                i === (newPrimaryImageIndexForUpload || 0) && !makeExistingImagePrimary
                            ]
                        );
                    }
                }
            }
        }

        await connection.commit();
        return { success: true };
    } catch (error) {
        await connection.rollback();
        console.error('Error in updateProduct:', error);
        return { 
            success: false, 
            error: error instanceof Error ? error.message : 'Failed to update product' 
        };
    } finally {
        connection.release();
    }
}

export async function deleteProduct(productId: string): Promise<{ success: boolean; error?: string }> {
    const connection = await pool.getConnection();
    try {
        await connection.beginTransaction();

        // Get all image paths first
        const [imageRows] = await connection.query<any[]>(
            'SELECT image_path FROM product_images WHERE product_id = ?',
            [productId]
        );

        // Delete files from the filesystem
        for (const row of imageRows) {
            try {
                await deleteFile(row.image_path);
            } catch (error) {
                console.error(`Failed to delete file ${row.image_path}:`, error);
                // Continue with deletion even if file removal fails
            }
        }

        // Delete product images from database (due to foreign key constraint)
        await connection.query('DELETE FROM product_images WHERE product_id = ?', [productId]);

        // Delete the product
        await connection.query('DELETE FROM products WHERE id = ?', [productId]);

        await connection.commit();
        return { success: true };
    } catch (error) {
        await connection.rollback();
        console.error('Error in deleteProduct:', error);
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Failed to delete product'
        };
    } finally {
        connection.release();
    }
}

export async function updateProductBestSellerStatus(productId: string, isBestSeller: boolean): Promise<{ success: boolean; error?: string }> {
    const connection = await pool.getConnection();
    try {
        await connection.query(
            'UPDATE products SET is_best_seller = ?, updated_at = NOW() WHERE id = ?',
            [isBestSeller, productId]
        );
        return { success: true };
    } catch (error) {
        console.error('Error in updateProductBestSellerStatus:', error);
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Failed to update best seller status'
        };
    } finally {
        connection.release();
    }
}

export async function getTodaysSalesSummary(): Promise<TodaysSalesSummary> {
    const [rows] = await executeQuery<any[]>(`
        SELECT COUNT(*) as ordersToday, 
               SUM(quantity_sold * price) as salesTodayAmount
        FROM product_sales
        WHERE DATE(sale_date) = CURDATE()
    `);

    const row = rows[0];
    return {
        ordersToday: row.ordersToday || 0,
        salesTodayAmount: Number(row.salesTodayAmount) || 0
    };
}

export async function getProductSalesSummary(
    limit: number = 10,
    startDate?: Date,
    endDate?: Date
): Promise<ProductSaleSummary[]> {
    const dateFilter = startDate && endDate
        ? 'WHERE sale_date BETWEEN ? AND ?'
        : '';

    const params: (Date | number)[] = startDate && endDate ? [startDate, endDate] : [];
    if (limit) params.push(limit);

    const rows = await executeQuery<any[]>(`
        SELECT p.id as productId, p.name as productName,
               SUM(ps.quantity_sold) as totalQuantitySold
        FROM products p
        LEFT JOIN product_sales ps ON p.id = ps.product_id
        ${dateFilter}
        GROUP BY p.id, p.name
        ORDER BY totalQuantitySold DESC
        LIMIT ?
    `, params);

    return rows.map(row => ({
        productId: row.productId,
        productName: row.productName,
        totalQuantitySold: Number(row.totalQuantitySold) || 0
    }));
}

export async function getTopSalesByQuantity(
    limit: number = 10,
    startDate?: Date,
    endDate?: Date
): Promise<TopSaleByQuantity[]> {
    const dateFilter = startDate && endDate
        ? 'WHERE sale_date BETWEEN ? AND ?'
        : '';

    const params: (Date | number)[] = startDate && endDate ? [startDate, endDate] : [];
    if (limit) params.push(limit);

    const rows = await executeQuery<any[]>(`
        SELECT ps.id, p.name as productName, ps.quantity_sold as quantitySold,
               ps.sale_date as saleDate
        FROM product_sales ps
        JOIN products p ON ps.product_id = p.id
        ${dateFilter}
        ORDER BY ps.quantity_sold DESC
        LIMIT ?
    `, params);

    return rows.map(row => ({
        id: row.id,
        productName: row.productName,
        quantitySold: Number(row.quantitySold),
        saleDate: row.saleDate.toISOString()
    }));
}

export async function getProductRevenueSummary(
    limit: number = 10,
    startDate?: Date,
    endDate?: Date
): Promise<ProductRevenueSummary[]> {
    const dateFilter = startDate && endDate
        ? 'WHERE sale_date BETWEEN ? AND ?'
        : '';

    const params: (Date | number)[] = startDate && endDate ? [startDate, endDate] : [];
    if (limit) params.push(limit);

    const rows = await executeQuery<any[]>(`
        SELECT p.id as productId, p.name as productName,
               SUM(ps.quantity_sold * p.price) as totalRevenue
        FROM products p
        LEFT JOIN product_sales ps ON p.id = ps.product_id
        ${dateFilter}
        GROUP BY p.id, p.name
        ORDER BY totalRevenue DESC
        LIMIT ?
    `, params);

    return rows.map(row => ({
        productId: row.productId,
        productName: row.productName,
        totalRevenue: Number(row.totalRevenue) || 0
    }));
}
